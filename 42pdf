#!/bin/bash

display_help() {
	cat << EOF
Usage: ./42pdf NAME/ID [OPTIONS]

Instantly download pdf's from 42

Arguments:
 NAME/ID        The name or id of the PDF to download
 --find         Find and download a PDF in the database
 pack           Shows available packs

Options:
 -h, --help     Display this help message
 -b, --browser  Open the PDF in browser
 -t, --title    Display the PDF title
 -s, --summary  Display the PDF summary
 -v, --version  Display the PDF version
 -p, --page [N] Display content of page N
EOF
	exit 0
}

check_errors() {
	script_dir="$(dirname "$(realpath "${BASH_SOURCE[0]}")")"
	db_name=$script_dir/pdf_db.txt
	if [ "$GITHUB_ACTIONS" = "true" ]; then
		return 0
	fi
	if [ $# -gt 3 ]; then
		echo "Too many arguments"
		exit 1
	fi
	if [ -z "$1" ] || [ "$1" == "-h" ] || [ "$1" == "--help" ]; then
		display_help
	fi
	if [ ! -f $db_name ] || [ ! -s $db_name ]; then
		echo "$db_name does not exist or is empty"
		echo "Clone the repo and execute 42pdf from there"
		echo "git clone https://github.com/andrexandre/42_pdf_downloader.git && cd 42_pdf_downloader"
		exit 1
	fi
	if ! timeout 3 ping -c 1 google.com &> /dev/null; then
		echo "Bad internet connection"
		exit 1
	fi
	if ! command -v pdftotext &> /dev/null; then
		echo "pdftotext is required but not installed. Do you want to install it now? (Ctrl+C to exit)"
		sudo apt-get update && sudo apt-get install -y poppler-utils
		if [ $? -eq 1 ]; then
			exit 0
		fi
	fi
	# if [ ! -f "$HOME/.local/bin/42pdf" ]; then
	# 	ln -s "$(realpath "$0")" "$HOME/.local/bin/42pdf"
	# fi
}

migrate_database() {
	if [ ! -f new_pdf_db.txt ]; then
		echo There is no file new_pdf_db.txt
		return 1
	fi
	updating_started=false
	while IFS= read -r curr_line; do
		if [[ "$curr_line" == "$start_id" ]]; then
			updating_started=true
			echo Started migration from $start_id
			continue
		fi
		if [ "$updating_started" == true ]; then
			start_id=$(echo $curr_line | awk '{print $1}')
			url=https://cdn.intra.42.fr/pdf/pdf/$start_id/en.subject.pdf
			# commands to check the existance of pdf on server
			status_code=$(curl -s -f -o /dev/null -w "%{http_code}\n" --head $url)
			if [ "$status_code" -eq 200 ]; then
				pdf_name=$(curl -s -f -o - $url | pdftotext -l 1 - - | head -n 1)
				echo "$curr_line $pdf_name" >> $db_name
			fi
		fi
	done < new_pdf_db.txt
	if [ "$updating_started" == false ]; then
		echo There is nothing to migrate
	else
		echo Everything migrated successfully
	fi
}

update_database_in_order() {
	echo Started updating from $start_id to $end_id
	for (( i=start_id; i<=end_id; i++ ))
	do
		url=https://cdn.intra.42.fr/pdf/pdf/$i/en.subject.pdf
		status_code=$(curl -s -f -o /dev/null -w "%{http_code}\n" --head $url)
		if [ "$status_code" -eq 200 ]; then
			pdf_name=$(curl -s -f -o - $url | pdftotext -l 1 - - | head -n 1)
			echo "$i $pdf_name" >> pdf_db.txt
			# auto restart
			# let end_id=i+id_batch_size
		fi
	done
}

update_database_real_fast() {
	echo Started updating from $start_id to $end_id
	threads_num=200
	seq $start_id $end_id | xargs -P $threads_num -I {} bash -c '
		url=https://cdn.intra.42.fr/pdf/pdf/{}/en.subject.pdf
		status_code=$(curl -s -f -o /dev/null -w "%{http_code}\n" --head $url)
		if [ "$status_code" -eq 200 ]; then
			pdf_name=$(curl -s -f -o - $url | pdftotext -l 1 - - | head -n 1)
			echo "{} $pdf_name" >> pdf_db.txt
		fi
	'
	# $db_name it's not used here so i remeber that it can't be used on xargs
	sort -n -o pdf_db.txt pdf_db.txt
}

search_and_download_by_name() {
	found_line_index=$(cat $db_name | cut -d' ' -f2- | grep -nwxi "$1" | tail -n 1 | awk -F':' '{print $1}')
	if [ -z "$found_line_index" ]; then
		echo "No pdf called $1 found"
		return 1
	fi
	# parse pdf variables
	pdf_id=$(sed -n "${found_line_index}p" $db_name | awk '{print $1}')
	pdf_name=$(sed -n "${found_line_index}p" $db_name | cut -d' ' -f2- | tr ' ' '-' |  tr '/' '-' | sed 's/--*/-/g')
	url=https://cdn.intra.42.fr/pdf/pdf/$pdf_id/en.subject.pdf
	curl -sfo $pdf_name.subject.pdf $url
	if [ $? -eq 0 ]; then
		if [ -n "$2" ]; then
			handle_download_args "$@"
		else
			echo "Downloaded $pdf_name subject of id: $pdf_id"
		fi
	else
		echo "$pdf_name subject of id: $pdf_id isn't available"
		echo "Search on intra for $pdf_name to verify if it exists"
		return 1
	fi
}

download_by_id() {
	pdf_id="$1"
	url=https://cdn.intra.42.fr/pdf/pdf/$pdf_id/en.subject.pdf
	curl -sfo temp.subject.pdf $url
	if [ $? -eq 0 ]; then
		pdf_name=$(pdftotext -l 1 temp.subject.pdf - | head -n 1 | tr ' ' '-' |  tr '/' '-' | sed 's/--*/-/g')
		mv temp.subject.pdf "$pdf_name.subject.pdf"
		if [ -n "$2" ]; then
			handle_download_args "$@"
		else
			echo "Downloaded $pdf_name subject of id: $pdf_id"
		fi
	else
		echo "Subject of id: $pdf_id isn't available"
		return 1
	fi
}

handle_download_args() {
	trim_characters() {
		# Remove leading/trailing whitespace and empty lines
		sed 's/^[[:space:]]*//;s/[[:space:]]*$//;/^[[:space:]]*$/d' | tr -s '\n'
	}
	case "$2" in
		--browser|-b)
			open $url
			;;
		--title|-t)
			echo $pdf_name
			;;
		--summary|-s)
			if pdftotext -l 1 "$pdf_name.subject.pdf" - | grep -q 'Version:'; then
				pdftotext -l 1 "$pdf_name.subject.pdf" - | sed -n '/Summary:/,/Version:/ {s/Summary://; /Version:/q; p}' | trim_characters
			else
				pdftotext -l 1 "$pdf_name.subject.pdf" - | sed -n '/Summary:/,$ {s/Summary: //; p}' | trim_characters
			fi
			;;
		--version|-v)
			if pdftotext -l 1 "$pdf_name.subject.pdf" - | grep -q 'Version:'; then
				pdftotext -l 1 "$pdf_name.subject.pdf" - | grep 'Version:' | cut -d' ' -f2;
			else
				echo "This pdf doesn't have version";
			fi
			;;
		--page|-p)
			if [ -n "$3" ]; then
				pdftotext -f $3 -l $3 "$pdf_name.subject.pdf" -
			else
				pdftotext "$pdf_name.subject.pdf" -
			fi
			;;
		*)
			echo "Invalid option: $2"
			echo "try './42pdf --help' for more information"
			;;
	esac
	rm $pdf_name.subject.pdf
}

fzf_search() {
	CMD=fzf
	[ -d "$HOME/.local/bin" ] || mkdir -p "$HOME/.local/bin"
	[[ ":$PATH:" != *":$HOME/.local/bin:"* ]] && export PATH="$HOME/.local/bin:$PATH"
	if ! command -v $CMD &> /dev/null; then
		echo Downloading $CMD...
		TEMP_DIR=$(mktemp -d)
		cd $TEMP_DIR
		apt-get download $CMD > /dev/null
		dpkg -x $CMD*.deb $TEMP_DIR/$CMD
		rm $CMD*.deb
		cp $TEMP_DIR/$CMD/usr/bin/$CMD $HOME/.local/bin
		rm -rf $TEMP_DIR/$CMD
		cd - > /dev/null
		rmdir $TEMP_DIR
	fi
	pdf_name=$(cat $db_name | cut -d' ' -f2- | sort | uniq | fzf)
	if [ -z "$pdf_name" ]; then
		return 0
	else
		search_and_download_by_name "$pdf_name"
	fi
}

download_pack() {
	pack_name="$2"
	case "$pack_name" in
		"common_core")
			echo "Downloading Common Core pack..."
			mkdir -p "common_core"
			for project in "Libft" "ft_printf" "Get Next Line" "Born2beRoot" "minitalk" \
					"pipex" "push_swap" "fdf" "fract’ol" "So Long" "philosophers" "minishell" \
					"Net_Practice" "miniRT" "cub3d" "inception" "webserv" "ft_irc" "ft_transcendence"; do
				search_and_download_by_name "$project"
				mv "$pdf_name.subject.pdf" "common_core"
			done
			;&
		"cpp_modules")
			echo "Downloading C++ Modules pack..."
			mkdir -p "cpp_modules"
			for i in {00..09}; do
				search_and_download_by_name "C++ - Module $i"
				mv "$pdf_name.subject.pdf" "cpp_modules"
			done
			if [ "$pack_name" == "common_core" ]; then
				mv "cpp_modules" "common_core"
			fi
			;;
		"mysterious")
			echo "Downloading Mysterious pack..."
			search_and_download_by_name "???"
			search_and_download_by_name "β"
			search_and_download_by_name "6/2/2023"
			;;
		"all_42_pdf")
			echo "Downloading All 42 subjects pack..."
			mkdir -p "all_42_pdf"
			all_subjects=$(cat $db_name | cut -d' ' -f2- | sort | uniq)
			echo "$all_subjects" | while read -r project; do
				search_and_download_by_name "$project"
				mv "$pdf_name.subject.pdf" "all_42_pdf"
			done
			;;
		*)
			echo "Usage: ./42pdf pack <pack_name>"
			echo
			echo "Available packs:"
			echo "- cpp_modules  : C++ Modules subjects"
			echo "- common_core  : Common Core subjects"
			echo "- all_42_pdf   : Almost all 42 subjects (-1gb)"
			echo "- mysterious   : Hella sus subjects"
			;;
	esac
}

main() {
	# --update/--migrate variables
	start_id=$(cat $db_name | tail -n 1 | awk '{print $1}')
	id_batch_size=1000 # cut batch_size to half in need of workflow minutes
	let start_id=start_id+1
	let end_id=start_id+id_batch_size
	case "$1" in
		-f|--find)
			fzf_search
			;;
		--update)
			# update_database_in_order
			update_database_real_fast
			;;
		--migrate)
			migrate_database
			;;
		-*)
			echo "Invalid argument: $1"
			echo "try './42pdf --help' for more information"
			;;
		pack)
			download_pack "$@"
			;;
		*[!0-9]*)
			search_and_download_by_name "$@"
			;;
		*)
			download_by_id "$@"
			;;
	esac
}

check_errors "$@"
main "$@"

# git clone git@github.com:42Paris/minilibx-linux.git
